// 객체 지향 프로그래밍(OOP) 의 4대 원리 - 1
/*
1. 캡슐화 (Encapsulation)
- 정의 : 데이터(멤버 변수)와 기능(멤버 메서드)을 하나의 단위로 묶어 놓음.
- 변수들을 안으로 감출 때 데이터 은닉(ex.변수는 private / 메서드는 public -> 이렇게 하면 사용자는 메서드에 대한 정보만 알고 사용하면 되는 편리함.)
- 언제든 사용하면 좋음!
- 데이터 은닉 : 데이터를 보이지 않게 가리고, 데이터에 접근하기 위한 메서드만을 노출

- 사용이유 : 클래스 사용자 -> 클래스 내부 구조 이해 x, 사용법만 이해 o 사용 가능, 데이터를 실수로 잘 못 바꾸는 것을 방지
- 사용방법 : 클래스 안에 멤버 변수, 멤버 메서드 선언 + 접근 제어

2. 상속성 (Inheritance)
- 정의 : 부모 클래스의 멤버를 재사용해서 자식 클래스에서도 사용할 수 있음.
- 부모 클래스에서 할 수 있는 일을 자식 클래스에서도 할 수 있을 때 사용 (*Liskov 치환 원칙)
- 자식 클래스는 부모 클래스의 일종이다 (A is a B)

- 사용 이유 : 코드 재사용
- 사용 방법 : 상속을해서 사용

3. 다형성 (Polymorphism)
- 정의 :
동적 다형성 -> 한 클래스가 그로부터 파생된 다양한 형태를 지닐 수 있음.
정적 다형성 -> 함수 오버로딩, 템플릿
- 자식 클래스의 메서드 구현이 부모 클래스와 다를 때 사용.

- 사용 이유 : 자식 클래스에서 하고 싶은 일들이 부모 클래스에서와 다를 수 있기 때문에 사용.
- 사용 방법 : 오버라이딩, 가상함수 (RTTI, 다형 클래스)

4. 추상화 (Abstraction)
- 정의 :
부모 클래스 -> 클래스가 구현해야 할 기능만을 명시 (순수 가상 함수)
자식 클래스 -> 실제 구현
- [자식 클래스]는 [부모 클래스] 할 수 있어야 한다. (A is able to B)
- 사용 방법 : 추상 클래스 생성 (순수 가상 함수)


# SOLID 원칙
1.단일 책임 원칙 (Single Responsibility Principle, SRP):
한 클래스는 단 하나의 책임을 가져야 합니다. 즉, 클래스는 변경되어야 하는 이유가 오직 하나여야 합니다.
이는 클래스가 변경될 때 다른 부분에 영향을 미치는 범위를 최소화하여 유지보수성을 향상시킵니다.

2.개방-폐쇄 원칙 (Open-Closed Principle, OCP):
소프트웨어의 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 합니다.
즉, 기존의 코드를 변경하지 않고도 새로운 기능을 추가할 수 있어야 합니다. 이는 코드의 안정성과 확장성을 높입니다.

3.리스코프 치환 원칙 (*Liskov Substitution Principle, LSP):
상속 관계에서는 서브타입은 언제나 기반 타입으로 교체 가능해야 합니다.
즉, 서브클래스는 기반클래스의 기능을 오버라이드하거나 확장할 수 있고, 부모 클래스의 역할을 모두 대체할 수 있어야 합니다.

4.인터페이스 분리 원칙 (Interface Segregation Principle, ISP):
클라이언트는 자신이 사용하지 않는 인터페이스에 의존하지 않아야 합니다.
즉, 인터페이스는 클라이언트에게 필요한 최소한의 기능만을 제공해야 합니다. 이는 인터페이스의 간결성과 응집력을 높이며, 결합도를 낮춥니다.

5.의존성 역전 원칙 (Dependency Inversion Principle, DIP):
고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 양쪽 모두 추상화에 의존해야 합니다.
즉, 추상화된 인터페이스를 통해 의존성을 주입받아야 합니다. 이는 코드의 유연성과 재사용성을 높입니다.

*/